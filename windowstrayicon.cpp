#include <QtGlobal>  // for the definition of Q_OS_WIN

#ifdef Q_OS_WIN  // do not compile the whole .cpp file on platforms other than windows

#include <QCoreApplication>
#include <QWidget>
#include <QWindow>
#include <QPixmap>
#include <QAbstractNativeEventFilter>
#include <QHash>
#include <QTimer>
#include <QCursor>
#include <QtWin>
#include <QDebug>

#include <string>

#include "windowstrayicon.h"

#undef _WIN32_WINNT
#undef _WIN32_IE
#undef NTDDI_VERSION
#define _WIN32_WINNT _WIN32_WINNT_VISTA
#define _WIN32_IE _WIN32_IE_LONGHORN
#define NTDDI_VERSION NTDDI_VISTA
#include <Windows.h>
#include <windowsx.h>
#include <shellapi.h>
#define WM_TRAYMESSAGE (WM_APP + 101)


class WindowsTrayMessageFilter: public QAbstractNativeEventFilter {
protected:
    WindowsTrayMessageFilter() {
        next_iconId = 1;
    }

    static WindowsTrayMessageFilter *s_instance;
    uint next_iconId = 0;
    QHash<uint, WindowsTrayIconPrivate *> handlers;

public:
    static WindowsTrayMessageFilter *instance() {
        if (s_instance == nullptr) {
            s_instance = new WindowsTrayMessageFilter();
            QCoreApplication::instance()->installNativeEventFilter(s_instance);
        }
        return s_instance;
    }

    static uint nextIconId() {
        instance()->next_iconId++;
        return s_instance->next_iconId;
    }

    static void addCallbackHandler(uint iconId, WindowsTrayIconPrivate *handler) {
        instance()->handlers.insert(iconId, handler);
    }

    virtual ~WindowsTrayMessageFilter() {
        //
    }

public:
    virtual bool nativeEventFilter(const QByteArray &eventType, void *message, long *result) {
        if ((eventType == "windows_generic_MSG") || (eventType == "windows_dispatcher_MSG")) {
            MSG *msg = static_cast<MSG *>(message);
            if (result) *result = 0;

            if (msg->message == WM_TRAYMESSAGE) {
                // When the uVersion member is NOTIFYICON_VERSION_4, the interpretation of the
                // lParam and wParam parameters of that message is changed as follows:
                // - LOWORD(lParam) contains notify events, such as NIN_BALLOONSHOW, NIN_POPUPOPEN, or WM_CONTEXTMENU.
                // - HIWORD(lParam) contains the icon ID. Icon IDs are restricted to a length of 16 bits.
                // - GET_X_LPARAM(wParam) returns the X anchor coordinate for notification events
                //   NIN_POPUPOPEN, NIN_SELECT, NIN_KEYSELECT, and all mouse messages between
                //   WM_MOUSEFIRST and WM_MOUSELAST. If any of those messages are generated by
                //   the keyboard, wParam is set to the upper-left corner of the target icon.
                //   For all other messages, wParam is undefined.
                uint iconId = HIWORD(msg->lParam);
                // call message handler for this icon
                if (iconId > 0)
                    this->call_handler(iconId, msg);
                return true;
            }
        }
        return false;
    }

protected:
    void call_handler(uint iconId, MSG *msg);
};


// static
WindowsTrayMessageFilter *WindowsTrayMessageFilter::s_instance = nullptr;


class WindowsTrayIconPrivate {
public:
    explicit WindowsTrayIconPrivate(WindowsTrayIcon *parent) {
        ownerIcon = parent;
        ownerHwnd = NULL;
        visible = false;
        hover_allowEmit = true;
        windows_hIcon = NULL;
        iconId = (UINT)WindowsTrayMessageFilter::nextIconId();
        WindowsTrayMessageFilter::addCallbackHandler(iconId, this);
        //
        hover_x = hover_y = 0;
        hoverTimer.setSingleShot(true);
        hoverTimer.setInterval(400);
        QObject::connect(&hoverTimer, &QTimer::timeout, ownerIcon,
                         &WindowsTrayIcon::privateSlot1);
        hoverDisableEmitTimer.setSingleShot(true);
        hoverDisableEmitTimer.setInterval(1000);
        QObject::connect(&hoverDisableEmitTimer, &QTimer::timeout,
                         ownerIcon, &WindowsTrayIcon::privateSlot2);
    }

    ~WindowsTrayIconPrivate() {
        // cleanup some resources that may be left over
        if (windows_hIcon != NULL) {
            DestroyIcon(windows_hIcon); // call Win32 API
            windows_hIcon = NULL;
        }
    }

    void setHwnd(HWND parentHwnd) {
        ownerHwnd = parentHwnd;
    }

    void init_notifyIconData(NOTIFYICONDATAW *pData) {
        memset(pData, 0, sizeof(NOTIFYICONDATAW));
        pData->cbSize = sizeof(NOTIFYICONDATAW);
        pData->hWnd = ownerHwnd;
        pData->uID = iconId;
        pData->uFlags = NIF_MESSAGE | NIF_TIP | NIF_STATE;
        pData->uCallbackMessage = WM_TRAYMESSAGE;
        pData->uVersion = NOTIFYICON_VERSION_4;
        if (!toolTip.isEmpty()) {
            std::wstring wstr = toolTip.toStdWString();
            wcsncpy(pData->szTip, wstr.c_str(), sizeof(pData->szTip)/sizeof(WCHAR) - 1);
            //pData->dwInfoFlags = NIIF_INFO | NIIF_NOSOUND;
            //wcsncpy(pData->szInfo, wstr.c_str(), sizeof(pData->szInfo)/sizeof(WCHAR) - 1);
            //wcsncpy(pData->szInfoTitle, L"tray balloon", sizeof(pData->szInfoTitle)/sizeof(WCHAR) - 1);
        }
        if (!icon.isNull()) {
            pData->uFlags = pData->uFlags | NIF_ICON;
            // setup icon. convert QIcon to HICON (using QWinExtras)
            // this creates NEW win32 icon handle, we must free this resource some time
            pData->hIcon = QtWin::toHICON(icon.pixmap(32, 32));
            // cleanup possible previous win32 HICON
            if (windows_hIcon != NULL) {
                DestroyIcon(windows_hIcon);
            }
            // remember allocated icon resource
            windows_hIcon = pData->hIcon;
        }
    }

    void add_trayIcon() {
        NOTIFYICONDATAW ndata;
        init_notifyIconData(&ndata);
        BOOL ret = FALSE;
        ret = Shell_NotifyIconW(NIM_ADD, &ndata);
        Q_ASSERT(ret == TRUE);
        ret = Shell_NotifyIconW(NIM_SETVERSION, &ndata);
        Q_ASSERT(ret == TRUE);
    }

    void remove_trayIcon() {
        NOTIFYICONDATAW ndata;
        init_notifyIconData(&ndata);
        BOOL ret = FALSE;
        ret = Shell_NotifyIconW(NIM_DELETE, &ndata);
        Q_ASSERT(ret == TRUE);
    }

    void edit_trayIcon() {
        NOTIFYICONDATAW ndata;
        init_notifyIconData(&ndata);
        BOOL ret = FALSE;
        ret = Shell_NotifyIconW(NIM_MODIFY, &ndata);
        Q_ASSERT(ret == TRUE);
    }

//public Q_SLOTS:
    void setVisible(bool vis) {
        if (vis && visible) return; // already visible
        if (!vis && !visible) return; // already invisible
        visible = vis;
        if (visible) {
            // make visible
            add_trayIcon();
        } else {
            // make invisible
            remove_trayIcon();
        }
    }

    void setToolTip(const QString& tip) {
        toolTip = tip;
        if (visible) edit_trayIcon();
    }

    void setIcon(const QIcon& ico) {
        icon = ico;
        if (visible) edit_trayIcon();
    }

    void on_activate(QSystemTrayIcon::ActivationReason reason) {
        hoverTimer.stop();
        hover_allowEmit = false;
        hoverDisableEmitTimer.start();
        emit ownerIcon->activated(reason);
    }

    void on_mouseMove(int x, int y) {
        hover_x = x;
        hover_y = y;
        hoverTimer.stop();
        hoverTimer.start();
    }

    void trigger_hover() {
        hoverTimer.stop();
        if (hover_allowEmit) {
            QPoint cpos = QCursor::pos();
            int delta_x = qAbs(cpos.x() - hover_x);
            int delta_y = qAbs(cpos.y() - hover_y);
            // only emit hover event if cursor did not move too far
            const int tolerance = 16; // tray icons in windows are 16x16
            if ((delta_x <= tolerance) && (delta_y <= tolerance))
                emit ownerIcon->mouseHovered(hover_x, hover_y);
        }
    }

    void allow_emit_mouseHover() {
        hover_allowEmit = true;
    }


    WindowsTrayIcon *ownerIcon;
    QTimer hoverTimer;
    QTimer hoverDisableEmitTimer;
    int hover_x;
    int hover_y;
    bool hover_allowEmit;

    HWND ownerHwnd;
    UINT iconId;
    QIcon icon;
    HICON windows_hIcon; // win32 icon resource handle
    QString toolTip;
    bool visible;

private:
    Q_DISABLE_COPY(WindowsTrayIconPrivate)
};


// this function needs to be below ROWindowsTrayIconPrivate class declaration
void WindowsTrayMessageFilter::call_handler(uint iconId, MSG *msg) {
    // first, find handler for this tray icon
    if (!handlers.contains(iconId)) {
        qWarning() << "No handler for icon id: " << iconId;
        return;
    }
    WindowsTrayIconPrivate *handler = handlers[iconId];
    if (!handler) return; // avoid dereference nullptr
    //
    uint notify_event = LOWORD(msg->lParam);
    int x = GET_X_LPARAM(msg->wParam);
    int y = GET_Y_LPARAM(msg->wParam);
    switch (notify_event) {
    case WM_MOUSEMOVE:
        handler->on_mouseMove(x, y);
        break;
    case WM_LBUTTONUP:
        handler->on_activate(QSystemTrayIcon::Trigger);
        break;
    case WM_CONTEXTMENU:
        handler->on_activate(QSystemTrayIcon::Context);
        break;
    case WM_MBUTTONUP:
        handler->on_activate(QSystemTrayIcon::MiddleClick);
        break;
    case WM_LBUTTONDBLCLK:
        handler->on_activate(QSystemTrayIcon::DoubleClick);
        break;
    // code below was for testing and it does not work :(
    //case NIN_POPUPOPEN:
    //    qDebug() << "NIN_POPUPOPEN";
    //    break;
    //case NIN_POPUPCLOSE:
    //    qDebug() << "NIN_POPUPOPEN";
    //    break;
    //case NIN_BALLOONSHOW:
    //    qDebug() << "NIN_BALLOONSHOW";
    //    break;
    //case NIN_BALLOONHIDE:
    //    qDebug() << "NIN_BALLOONHIDE";
    //    break;
    }
}


WindowsTrayIcon::WindowsTrayIcon(QObject *parent):
    QObject(parent), d(new WindowsTrayIconPrivate(this))
{
    //
}


WindowsTrayIcon::WindowsTrayIcon(const QIcon &icon, QObject *parent):
    QObject(parent), d(new WindowsTrayIconPrivate(this))
{
    setIcon(icon);
}


void WindowsTrayIcon::setOwnerWidget(QWidget *widget) {
    d->setHwnd((HWND)widget->winId());
}


void WindowsTrayIcon::setOwnerWindow(QWindow *window) {
    d->setHwnd((HWND)window->winId());
}


WindowsTrayIcon::~WindowsTrayIcon() {
    if (isVisible()) setVisible(false);
    delete d;
}


QIcon WindowsTrayIcon::icon() const {
    return d->icon;
}


QString WindowsTrayIcon::toolTip() const {
    return d->toolTip;
}


bool WindowsTrayIcon::isVisible() const {
    return d->visible;
}


void WindowsTrayIcon::setIcon(const QIcon &icon) {
    d->setIcon(icon);
}


void WindowsTrayIcon::setVisible(bool visible) {
    d->setVisible(visible);
}


void WindowsTrayIcon::setToolTip(const QString &tip) {
    d->setToolTip(tip);
}


void WindowsTrayIcon::privateSlot1() {
    d->trigger_hover();
}


void WindowsTrayIcon::privateSlot2() {
    d->allow_emit_mouseHover();
}


bool WindowsTrayIcon::isSystemTrayAvailable() { return true; }

bool WindowsTrayIcon::supportsMessages() { return true; }

void WindowsTrayIcon::showMessage(const QString &title, const QString &msg,
        QSystemTrayIcon::MessageIcon icon, int msecs) {
    Q_UNUSED(title)
    Q_UNUSED(msg)
    Q_UNUSED(icon)
    Q_UNUSED(msecs)
    return;
}

#endif  // Q_OS_WIN
